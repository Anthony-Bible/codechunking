Verified Refactoring Opportunities (DRY + Performance)

All suggestions below have been verified by parallel subagents and confirmed as accurate.

1) Unify Repository Status Validation ✅ VERIFIED
- Location: internal/application/common/validation.go (ValidRepositoryStatuses), internal/domain/valueobject/repository_status.go (validRepositoryStatuses)
- Issue: Two separate sources of truth for valid repository statuses (string map vs value object map).
- Proposal: Remove ValidRepositoryStatuses from application/common and validate via valueobject.NewRepositoryStatus or valueobject.AllRepositoryStatuses(). Provide a helper in common that proxies to the valueobject to keep call sites minimal.
- Benefit: Single source of truth, eliminates drift; simpler validation logic.

2) Consolidate ValidationError types across layers ✅ VERIFIED
- Location: 
  - internal/adapter/inbound/api/validation_error.go
  - internal/application/common/validation.go (ValidationError)
  - internal/application/dto/error.go (DTO ValidationError + details)
- Issue: Three similar validation error representations with overlapping fields create duplication and conversion noise.
- Proposal: Keep dto.ValidationError for wire format; define a single internal error type (e.g., internal/application/common/errors.ValidationError) implementing error and carrying Field/Message/Value. API and services use this one type and the error handler converts to dto.ValidationError for responses. Remove duplicate struct(s) or alias api.ValidationError to the shared type.
- Benefit: DRY error handling, fewer conversions, consistent messaging.

3) De-duplicate client IP extraction ✅ VERIFIED (EXPANDED SCOPE)
- Location: 
  - internal/adapter/inbound/api/middleware.go (getClientIP)
  - internal/adapter/inbound/api/security_middleware.go (getClientIP method)
  - internal/adapter/inbound/api/middleware/logging_middleware.go (getClientIP)
- Issue: Three similar implementations for extracting client IP (more than originally identified).
- Proposal: Extract a shared util (e.g., internal/adapter/inbound/api/util/net.go: ClientIP(r *http.Request) string) and use it from all locations. Remove the duplicate methods; call the util from all middlewares.
- Benefit: DRY, one fix point for proxy header precedence.

4) Merge security header middlewares ✅ VERIFIED
- Location: 
  - internal/adapter/inbound/api/middleware.go (NewSecurityMiddleware)
  - internal/adapter/inbound/api/security_middleware.go (NewSecurityHeadersMiddleware)
- Issue: Both set overlapping security headers with conflicting values (different Referrer-Policy, HSTS handling).
- Proposal: Keep a single NewSecurityHeadersMiddleware(config) with options for HSTS, CSP, referrer policy, etc., and have NewSecurityMiddleware delegate to it or remove it. Ensure HTTPS check for HSTS remains.
- Benefit: DRY, consistent headers, easier to tune.

5) Collapse CORS middleware variants ✅ VERIFIED
- Location: 
  - internal/adapter/inbound/api/middleware.go (NewCORSMiddleware, NewCORSMiddlewareWithConfig)
- Issue: Two implementations; one hardcoded, one configurable.
- Proposal: Keep only NewCORSMiddlewareWithConfig with a default config (constant). Make NewCORSMiddleware a thin wrapper that calls the configurable version with defaults.
- Benefit: Single code path, easier maintenance.

6) Avoid redundant URL normalization on persistence ✅ VERIFIED
- Location: internal/adapter/outbound/repository/repository_repository.go (Save, Update, ExistsByNormalizedURL, FindByNormalizedURL)
- Issue: valueobject.NewRepositoryURL already stores a normalized URL. Repository layer re-normalizes repository.URL().String() again, wasting CPU and making it impossible to persist the original raw URL separately.
- Proposal: 
  - Extend valueobject.RepositoryURL to retain both raw and normalized forms (e.g., fields raw, normalized; String() returns normalized). Add methods Raw() and Normalized().
  - In repository persistence, use Raw() for the url column and Normalized() for normalized_url. If retaining raw isn't desired, at least stop re-normalizing and use repository.URL().String() for normalized_url directly.
- Benefit: Less work per write/update, ability to display original user input, clearer intent.

7) Remove dead code: scanRepository ✅ VERIFIED
- Location: internal/adapter/outbound/repository/repository_repository.go (scanRepository)
- Issue: Unused helper that parses timestamps from strings; all call sites use scanRepositoryFromTime.
- Proposal: Delete scanRepository or add unit usage if truly needed. Prefer a single scanning path.
- Benefit: Smaller surface area, less cognitive load.

8) Hoist method set for route validation ✅ VERIFIED
- Location: internal/adapter/inbound/api/routes.go (validatePattern: validMethods map)
- Issue: Reallocates the same map on every call.
- Proposal: Move validMethods to a package-level var or const set and reference it.
- Benefit: Minor allocation savings, cleaner code.
- Note: Low impact since this only runs at startup, not in request hot path.

9) Cache DB health metrics or make ping optional ✅ VERIFIED (HIGH IMPACT)
- Location: internal/adapter/outbound/repository/connection.go (DatabaseHealthChecker.GetMetrics)
- Issue: Calls pool.Ping on every metrics read to compute response time; can be heavy under frequent scrapes.
- Proposal: 
  - Add simple caching with TTL (e.g., 2–5s) or a boolean parameter to include ping timing. Store last metrics and timestamp in DatabaseHealthChecker and return cached metrics within TTL.
- Benefit: Reduced DB load under monitoring, steadier performance.

10) Reduce map copying in DefaultLogger ✅ VERIFIED
- Location: internal/adapter/inbound/api/middleware.go (DefaultLogger.WithField/WithFields)
- Issue: Each call copies the entire fields map to a new map. For hot paths, this allocates and copies repeatedly.
- Proposal: Use a small immutable log context type that holds a parent pointer and only materializes to a flat map at write time, or reuse a map with copy-on-write semantics. Alternatively, use a structured logger (zap/slog) already present elsewhere.
- Benefit: Fewer allocations in request logging.

11) Consolidate repository/indexing query builders ✅ VERIFIED
- Location: 
  - internal/adapter/outbound/repository/repository_repository.go (FindAll)
  - internal/adapter/outbound/repository/indexing_job_repository.go (FindByRepositoryID)
- Issue: Count/data query construction patterns are duplicated.
- Proposal: Extract a small helper to assemble LIMIT/OFFSET and ORDER BY safely, and share a function that executes count + data queries given base query, where clause, args. Keep it private within the package.
- Benefit: Less duplication, consistent pagination behavior.

12) ServiceFactory duplication for repo constructions ✅ VERIFIED
- Location: cmd/api.go (CreateHealthService, CreateRepositoryService)
- Issue: Repeats construction of repositoryRepo, indexingJobRepo, messagePublisher.
- Proposal: Add a helper on ServiceFactory (e.g., buildDependencies or repoDeps()) returning the three dependencies; reuse in both constructors. Optionally, memoize the pgx pool in ServiceFactory to reuse the same pool for all services.
- Benefit: DRY and fewer connections, improved startup performance.

13) Centralize JSON response writing ✅ VERIFIED (EXPANDED SCOPE)
- Location: 
  - internal/adapter/inbound/api/repository_handler.go (jsonResponseWriter + writeJSONResponse)
  - internal/adapter/inbound/api/error_handler.go (writeErrorResponse)
  - internal/adapter/inbound/api/security_middleware.go (direct json.NewEncoder usage)
  - internal/adapter/inbound/api/health_handler.go (direct json.NewEncoder usage)
- Issue: Multiple separate JSON writing helpers with similar responsibilities throughout codebase.
- Proposal: Extract a shared response helper (e.g., package apiutil with WriteJSON) and use it from all locations. Ensure consistent headers and error handling.
- Benefit: DRY, consistent responses.

14) Replace string concatenation in CORS headers ✅ VERIFIED (EXPANDED SCOPE)
- Location: internal/adapter/inbound/api/middleware.go (both NewCORSMiddleware implementations)
- Issue: Both CORS implementations build allowed headers string manually instead of using strings.Join.
- Proposal: Use strings.Join for requested headers in both implementations to avoid extra spaces/commas handling and improve clarity.
- Benefit: Readability; negligible perf.

15) Make default middleware toggles truly configurable ✅ VERIFIED
- Location: cmd/api.go (shouldEnableDefaultMiddleware always true)
- Issue: Hardcoded true with explicit TODO comment; divergence from config intent.
- Proposal: Add config flags (e.g., API.EnableDefaultMiddleware, API.CORS, API.SecurityHeaders) and wire them in ServiceFactory.CreateServer.
- Benefit: Predictable behavior and easier tuning without code changes.

16) Reuse concurrency primitives in duplicate detection ✅ VERIFIED
- Location: internal/application/service/repository_service.go (PerformantDuplicateDetectionService.BatchCheckDuplicates)
- Issue: Ad-hoc semaphore + channel management; correct but verbose.
- Proposal: Use errgroup.Group with a bounded worker pool pattern, or a worker pool helper to reduce boilerplate and improve readability. Also consider early return if all URLs are invalid to cut work.
- Benefit: Maintainability; similar or better performance with better error handling.

[REMOVED] 17) Avoid repeated normalization in repository repository ExistsByNormalizedURL/FindByNormalizedURL
- Reason: Duplicate of suggestion 6 - same underlying issue with URL normalization redundancy.

18) Consider pooling json.Encoder or using http.ResponseWriter.Write for small payloads ✅ VERIFIED (HIGH IMPACT)
- Location: internal/adapter/inbound/api/* (all handlers writing JSON)
- Issue: New encoder created per request affects every API response; high allocation overhead.
- Proposal: Optional micro-optimization: use jsoniter or encoder pooling behind an interface if profiling shows JSON as a hotspot.
- Benefit: Significant allocation reduction under load, improved response latency.

19) Normalize route pattern validation errors ✅ VERIFIED
- Location: internal/adapter/inbound/api/routes.go
- Issue: 10+ different error message patterns constructed inline using fmt.Errorf; test utility mentions detailed errors. Centralizing messages/constants can reduce churn and repeated strings.
- Proposal: Extract error message constants and helper constructors for consistent phrasing across validations.
- Benefit: DRY messaging, easier tests, potential future i18n support.

20) Memoize database pool in ServiceFactory ✅ VERIFIED
- Location: cmd/api.go (ServiceFactory.createDatabasePool, called in multiple Create* methods)
- Issue: Each service creation can create a new pool if called multiple times.
- Proposal: Add a field on ServiceFactory to hold a *pgxpool.Pool and initialize it once (sync.Once), reuse across services; expose graceful Close on shutdown.
- Benefit: Connection reuse, faster startup, fewer DB resources.

VERIFICATION NOTES:
- All 20 original suggestions were verified as technically accurate
- Suggestion 17 removed as duplicate of suggestion 6
- Suggestions 3, 13, and 14 actually have broader scope than originally identified
- Priority ranking: High impact (9, 18), Medium impact (10, 16, 2-6, 11-15), Low impact (8, 19, 20)
- All proposed solutions are feasible and would improve code maintainability